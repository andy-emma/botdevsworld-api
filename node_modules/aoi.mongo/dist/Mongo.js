"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mongo = void 0;
const Cursor_1 = require("./Cursor");
const Generator_1 = require("./Generator");
const query_1 = require("./query");
/** The mongo instance constructor */
class Mongo {
    /**
     * @param options The options for the mongo instance
     */
    constructor(options) {
        if (typeof options !== "object" || options === null)
            throw new TypeError("options must be a non-null object");
        if (typeof options.client !== "object" || options === null)
            throw new TypeError("client option must be a non-null object");
        if (typeof options.dbName !== "string")
            throw new TypeError("dbName option must be a valid string");
        if (typeof options.collectionName !== "string")
            throw new TypeError("collectionName option must be a valid string");
        this.client = options.client;
        this.db = this.client.db(options.dbName, options.dbOptions);
        this.collection = this.db.collection(options.collectionName, options.collectionOptions);
        void this.index({ key: 1 }, { unique: true });
    }
    /**
     * Set a data into the collection
     * @param key The data key
     * @param value The data value
     * @param session Session of transaction, if any
     */
    async set(key, value, session) {
        const refs = [];
        const data = (0, Generator_1.generate)(value, refs);
        const res = await this.collection.updateOne({ key }, {
            $setOnInsert: { key },
            $set: { data, refs }
        }, { upsert: true, session });
        return res;
    }
    /**
     * Get a document from the collection
     * @param key The document key
     * @param session Session of transaction, if any
     */
    async get(key, session) {
        return this.query(this.filter().key.equal(key), session).findOne();
    }
    /**
     * Delete a document from the collection
     * @param key The document key
     * @param session Session of transaction, if any
     */
    async delete(key, session) {
        return this.query(this.filter().key.equal(key), session).deleteOne();
    }
    /**
     * Find and match all document key with the matcher in the collection
     * @param matcher The matcher in regex
     * @param session Session of transaction, if any
     */
    async match(matcher, session) {
        return this.query(this.filter().key.match(matcher), session).findMulti();
    }
    /**
     * Get all document in the collection
     * @param session Session of transaction, if any
     */
    async all(session) {
        const cursor = await this.collection.find({}, { session });
        return new Cursor_1.Cursor(cursor);
    }
    /**
     * Delete all document in the collection
     * @param session Session of transaction, if any
     */
    deleteAll(session) {
        return this.collection.deleteMany({}, { session });
    }
    /** Create an index in the ocllection */
    async index(indexSpec, options) {
        const spec = {};
        if (typeof indexSpec.key !== "undefined")
            spec.key = indexSpec.key;
        if (typeof indexSpec.data !== "undefined") {
            if (typeof indexSpec.data === "object") {
                const keys = Object.keys(indexSpec.data);
                for (let i = 0; i < keys.length; i++) {
                    const key = keys[i];
                    if (!key.startsWith("$") && !key.includes(".") && !key.includes("\x00")) {
                        spec[`refs.0.${key}`] = indexSpec.data[key];
                    }
                }
            }
            else
                spec.data = indexSpec.data;
        }
        options ?? (options = {});
        await this.collection.createIndex(spec, options);
    }
    /** Create a query object */
    query(match, session) {
        return new query_1.Query(this, match, session);
    }
    /** Shortcut for creating filter */
    filter() {
        return new query_1.Filter();
    }
}
exports.Mongo = Mongo;
