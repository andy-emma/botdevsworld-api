"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransactionError = exports.Transaction = void 0;
const Mutex_1 = require("./Mutex");
const query_1 = require("./query");
const transactions = new WeakMap();
/** A wrapper of mongo class for transaction */
class Transaction {
    constructor(mongo) {
        this.mongo = mongo;
    }
    /** Start transaction for a mongo client */
    static async startTransaction(client, options) {
        const locker = transactions.get(client) ?? { mutex: new Mutex_1.Mutex() };
        if (locker.session)
            throw new TransactionError("Transaction already started");
        await locker.mutex.lock();
        locker.session = client.startSession();
        await locker.session.startTransaction(options);
        transactions.set(client, locker);
    }
    /** Commit transaction for a mongo client */
    static async commitTransaction(client) {
        const locker = transactions.get(client);
        if (!locker?.session)
            throw new TransactionError("Transaction is not started");
        await locker.session.commitTransaction();
        await endTransaction(client);
    }
    /** Abort transaction for a mongo client */
    static async abortTransaction(client) {
        const locker = transactions.get(client);
        if (!locker?.session)
            throw new TransactionError("Transaction is not started");
        await locker.session.abortTransaction();
        await endTransaction(client);
    }
    get session() {
        const locker = transactions.get(this.mongo.client);
        if (!locker?.session)
            throw new TransactionError("Transaction is not started");
        return locker.session;
    }
    /**
     * Set a data into the collection
     * @param key The data key
     * @param value The data value
     */
    set(key, value) {
        return this.mongo.set(key, value, this.session);
    }
    /**
     * Get a document from the collection
     * @param key The document key
     */
    get(key) {
        return this.mongo.get(key, this.session);
    }
    /**
     * Delete a document from the collection
     * @param key The document key
     */
    delete(key) {
        return this.mongo.delete(key, this.session);
    }
    /**
     * Find and match all document key with the matcher in the collection
     * @param matcher The matcher in regex
     */
    match(matcher) {
        return this.mongo.match(matcher, this.session);
    }
    /**
     * Get all document in the collection
     */
    all() {
        return this.mongo.all(this.session);
    }
    /**
     * Delete all document in the collection
     */
    deleteAll() {
        return this.mongo.deleteAll(this.session);
    }
    /** Create an index in the ocllection */
    index(indexSpec, options) {
        options ?? (options = {});
        options.session = this.session;
        return this.mongo.index(indexSpec, options);
    }
    /** Create a query object */
    query(match) {
        return new query_1.Query(this.mongo, match, this.session);
    }
    /** Shortcut for creating filter */
    filter() {
        return new query_1.Filter();
    }
}
exports.Transaction = Transaction;
async function endTransaction(client) {
    const locker = transactions.get(client);
    await locker.session.endSession();
    locker.session = undefined;
    locker.mutex.unlock();
}
/**
 * The class to represent transaction error
 */
class TransactionError extends Error {
    constructor(message) {
        super(message);
        this.name = "AoiMongoError";
    }
}
exports.TransactionError = TransactionError;
